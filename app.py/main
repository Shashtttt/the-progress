import os
from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from datetime import datetime, timedelta
import google.generativeai as genai
from dotenv import load_dotenv
import psycopg2
import json
from sqlalchemy import func


# Load environment variables from .env file
load_dotenv()

# Configure Gemini API
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
genai.configure(api_key=GOOGLE_API_KEY)

# Initialize Flask app
app = Flask(__name__, template_folder='templates')


@app.context_processor
def inject_now():
    return {'now': datetime.utcnow()}


app.config['SECRET_KEY'] = os.getenv("SECRET_KEY", "your-secret-key")
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv("DATABASE_URL",
                                                  "postgresql://myusers:newpassword@localhost/progress")
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize database
db = SQLAlchemy(app)
migrate = Migrate(app, db)

# Initialize Login Manager
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'


# Models
class User(UserMixin, db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(20), nullable=False)  # student, mentor, admin
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    tasks = db.relationship('Task', backref='user', lazy=True)
    progress_records = db.relationship('Progress', backref='user', lazy=True)
    reminders = db.relationship('Reminder', backref='user', lazy=True)

    # Add relationships for feedback
    feedback_given = db.relationship('Feedback', foreign_keys='Feedback.mentor_id', backref='mentor', lazy=True)
    feedback_received = db.relationship('Feedback', foreign_keys='Feedback.student_id', backref='student', lazy=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


class Task(db.Model):
    __tablename__ = 'tasks'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    type = db.Column(db.String(20), nullable=False)  # technical, aptitude, softskill
    status = db.Column(db.String(20), default='pending')  # pending, completed
    due_date = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    completed_at = db.Column(db.DateTime, nullable=True)

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'type': self.type,
            'status': self.status,
            'due_date': self.due_date.strftime('%Y-%m-%d') if self.due_date else None,
            'overdue': self.due_date and self.due_date < datetime.utcnow() and self.status != 'completed',
            'recently_added': self.created_at > datetime.utcnow() - timedelta(seconds=15)
        }


class Progress(db.Model):
    __tablename__ = 'progress'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    skill_area = db.Column(db.String(50), nullable=False)
    level = db.Column(db.String(20), nullable=False)  # Beginner, Intermediate, Advanced
    updated_at = db.Column(db.DateTime, default=datetime.utcnow)


class Reminder(db.Model):
    __tablename__ = 'reminders'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    message = db.Column(db.Text, nullable=False)
    trigger_time = db.Column(db.DateTime, nullable=False)
    sent = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'message': self.message,
            'trigger_time': self.trigger_time.strftime('%Y-%m-%d %H:%M'),
        }


class Feedback(db.Model):
    __tablename__ = 'feedback'

    id = db.Column(db.Integer, primary_key=True)
    mentor_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    student_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    message = db.Column(db.Text, nullable=False)
    rating = db.Column(db.Integer)  # 1-5 rating
    created_at = db.Column(db.DateTime, default=datetime.utcnow)


class Report(db.Model):
    __tablename__ = 'reports'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    report_type = db.Column(db.String(50), nullable=False)
    content = db.Column(db.JSON, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)


# Chat history model to store conversations
class ChatHistory(db.Model):
    __tablename__ = 'chat_history'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    message = db.Column(db.Text, nullable=False)
    response = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)




@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


def get_gemini_response(message, user_data=None, chat_history=None):
    try:
        # Try to use the latest model first
        try:
            model = genai.GenerativeModel('models/gemini-2.0-flash')
        except Exception:
            try:
                model = genai.GenerativeModel('models/gemini-1.5-pro')
            except Exception:
                model = genai.GenerativeModel('models/gemini-1.5-flash')

        system_prompt = """
        You are an intelligent progress tracking assistant for students and learners.
        Your role is to help users track their academic, technical, and personal growth.

        You have access to the user's tasks, progress, and reminders and update the dashboared when user ask to update. You can:
        1. Read task details when asked - respond with clear summaries of pending or completed tasks
        2. Help assign new tasks - extract task details and create structured tasks
        3. Track progress on skills - analyze and suggest progress updates
        4. Set and manage reminders - create reminders for important deadlines 
        5. Congratulate users on completed tasks - be encouraging and motivating
        6. Ask and take  test when user try to update skill - Don't allow user to update skill unless he he or she correct 5 question out of 10 in MCQ format

        Be supportive, specific, and actionable in your responses. When users complete tasks, celebrate their achievements.
        Use specific details from their data when possible.

        When users ask to create a task or set a reminder, extract the key information and format it in a structured way and update the dashboard with reminders and updated skills.
        When users update a skill ask to give a test for same language of 10 questions , if got more than 5 correct update the skill & if not don't update . 
        When users ask about their progress, provide insights based on their skill levels and task completion rates.
        """

        # Add user context if available
        if user_data:
            # Format recent tasks with more details
            tasks_info = []
            for task in user_data.get('recent_tasks', []):
                due_date_str = task.get('due_date').strftime('%Y-%m-%d %H:%M') if task.get(
                    'due_date') else "No due date"
                tasks_info.append(f"- {task.get('title')} ({task.get('status')}, due: {due_date_str})")

            # Format progress areas more clearly
            progress_info = []
            for prog in user_data.get('progress_areas', []):
                progress_info.append(f"- {prog.get('skill')}: {prog.get('level')}")

            # Get completion stats
            total_tasks = len(user_data.get('all_tasks', []))
            completed_tasks = sum(1 for task in user_data.get('all_tasks', []) if task.get('status') == 'completed')
            completion_rate = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0

            user_context = f"""
            User Information:
            - Name: {user_data.get('name', 'User')}
            - Role: {user_data.get('role', 'student')}

            Recent Tasks:
            {chr(10).join(tasks_info) if tasks_info else "No recent tasks"}

            Progress Areas:
            {chr(10).join(progress_info) if progress_info else "No progress areas recorded"}

            Task Completion:
            - Total Tasks: {total_tasks}
            - Completed: {completed_tasks} ({completion_rate:.1f}%)

            Recently Completed Tasks:
            {chr(10).join([f"- {task.get('title')}" for task in user_data.get('recently_completed', [])]) if user_data.get('recently_completed') else "No recently completed tasks"}

            Upcoming Reminders:
            {chr(10).join([f"- {reminder.get('message')} (due: {reminder.get('time')})" for reminder in user_data.get('upcoming_reminders', [])]) if user_data.get('upcoming_reminders') else "No upcoming reminders"}
            """
            system_prompt += user_context

        # Generate the response
        response = model.generate_content(system_prompt + "\n\nUser message: " + message)
        return response.text

    except Exception as e:
        print(f"Error generating response: {e}")
        return "I'm having trouble connecting to my systems. Could you try again in a moment? It appears there might be an API quota issue."


# Helper functions
def get_user_tasks(user_id):
    return Task.query.filter_by(user_id=user_id).order_by(Task.created_at.desc()).limit(10).all()


def get_user_reminders(user_id):
    return Reminder.query.filter_by(user_id=user_id, sent=False).order_by(Reminder.trigger_time).limit(5).all()


# Routes
@app.route('/')
def index():
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    return render_template('index.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')

        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('dashboard'))
        else:
            flash('Invalid email or password')

    return render_template('login.html')


@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        name = request.form.get('name')
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')

        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            flash('Email already exists')
            return redirect(url_for('register'))

        new_user = User(name=name, email=email, role=role)
        new_user.set_password(password)

        db.session.add(new_user)
        db.session.commit()

        flash('Registration successful! Please login.')
        return redirect(url_for('login'))

    return render_template('register.html')


@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))


@app.route('/dashboard')
@login_required
def dashboard():
    # Get user tasks
    tasks = Task.query.filter_by(user_id=current_user.id).order_by(Task.due_date).limit(5).all()

    # Get progress records
    progress_records = Progress.query.filter_by(user_id=current_user.id).all()

    # Get reminders
    reminders = Reminder.query.filter_by(user_id=current_user.id, sent=False).all()

    # Define levels mapping
    levels = {
        'beginner': 1,
        'intermediate': 2,
        'advanced': 3,
        'expert': 4
    }

    # For mentors, get their students
    students = []
    if current_user.role == 'mentor':
        student_ids = db.session.query(Feedback.student_id).filter_by(mentor_id=current_user.id).distinct().all()
        student_ids = [id[0] for id in student_ids]
        students = User.query.filter(User.id.in_(student_ids)).all() if student_ids else []

    # Task analytics
    task_analytics = {
        'labels': ['In Progress', 'Completed', 'Overdue'],
        'values': [
            Task.query.filter_by(user_id=current_user.id, status='in_progress').count(),
            Task.query.filter_by(user_id=current_user.id, status='completed').count(),
            Task.query.filter_by(user_id=current_user.id, status='pending')
            .filter(Task.due_date < datetime.utcnow()).count()
        ]
    }

    # Skill analytics
    skill_levels = db.session.query(
        Progress.level,
        func.count(Progress.id)
    ).filter_by(user_id=current_user.id).group_by(Progress.level).all()

    skill_analytics = {
        'labels': [level.capitalize() for level, _ in skill_levels] if skill_levels else [],
        'values': [count for _, count in skill_levels] if skill_levels else []
    }

    return render_template('dashboard.html',
                           tasks=tasks,
                           progress_records=progress_records,
                           reminders=reminders,
                           students=students,
                           levels=levels,
                           task_analytics=task_analytics,
                           skill_analytics=skill_analytics,
                           now=datetime.utcnow())


@app.route('/api/dashboard-data')
@login_required
def get_dashboard_data():
    tasks = get_user_tasks(current_user.id)
    reminders = get_user_reminders(current_user.id)
    return jsonify({
        'tasks': [task.to_dict() for task in tasks],
        'reminders': [reminder.to_dict() for reminder in reminders]
    })


@app.route('/tasks', methods=['GET', 'POST'])
@login_required
def tasks():
    if request.method == 'POST':
        title = request.form.get('title')
        description = request.form.get('description')
        task_type = request.form.get('type')
        due_date_str = request.form.get('due_date')

        due_date = None
        if due_date_str:
            try:
                # Try full datetime with time first
                due_date = datetime.strptime(due_date_str, '%Y-%m-%dT%H:%M')
            except ValueError:
                try:
                    # Fallback to date only
                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d')
                except ValueError:
                    flash('Invalid date format. Please enter a valid date.')
                    return redirect(url_for('tasks'))

        new_task = Task(
            user_id=current_user.id,
            title=title,
            description=description,
            type=task_type,
            due_date=due_date
        )

        db.session.add(new_task)
        db.session.commit()

        flash('Task added successfully!')
        return redirect(url_for('tasks'))

    tasks = Task.query.filter_by(user_id=current_user.id).order_by(Task.due_date).all()
    return render_template('tasks.html', tasks=tasks)


@app.route('/tasks/edit/<int:task_id>', methods=['GET', 'POST'])
@login_required
def edit_task(task_id):
    task = Task.query.get_or_404(task_id)

    if task.user_id != current_user.id:
        flash("You are not authorized to edit this task.")
        return redirect(url_for('tasks'))

    if request.method == 'POST':
        task.title = request.form.get('title')
        task.description = request.form.get('description')
        task.type = request.form.get('type')
        due_date_str = request.form.get('due_date')

        if due_date_str:
            try:
                task.due_date = datetime.strptime(due_date_str, '%Y-%m-%dT%H:%M')
            except ValueError:
                try:
                    task.due_date = datetime.strptime(due_date_str, '%Y-%m-%d')
                except ValueError:
                    flash('Invalid date format')
                    return redirect(url_for('edit_task', task_id=task.id))
        else:
            task.due_date = None

        db.session.commit()
        flash('Task updated successfully!')
        return redirect(url_for('tasks'))

    return render_template('edit_task.html', task=task)


@app.route('/tasks/complete/<int:task_id>', methods=['POST'])
@login_required
def complete_task(task_id):
    task = Task.query.get_or_404(task_id)

    if task.user_id != current_user.id:
        flash('Not authorized')
        return redirect(url_for('tasks'))

    task.status = 'completed'
    task.completed_at = datetime.utcnow()
    db.session.commit()

    # Add a congratulatory message
    try:
        # Create a simple congratulatory message without relying on API
        task_types = {
            'technical': 'technical skill development',
            'aptitude': 'aptitude improvement',
            'softskill': 'soft skill development'
        }

        congrats_messages = [
            f"Congratulations on completing '{task.title}'! Your progress in {task_types.get(task.type, 'learning')} is impressive.",
            f"Great job completing '{task.title}'! Keep up the excellent work on your {task_types.get(task.type, 'learning')} journey.",
            f"Task completed: '{task.title}'! You're making great strides in your {task_types.get(task.type, 'learning')} development.",
            f"Well done on finishing '{task.title}'! Your dedication to {task_types.get(task.type, 'learning')} is paying off."
        ]

        import random
        congrats_message = random.choice(congrats_messages)
        flash(congrats_message)
    except Exception as e:
        print(f"Error generating congratulatory message: {e}")
        flash('Task marked as completed!')

    return redirect(url_for('tasks'))


@app.route('/toggle-task/<int:task_id>', methods=['POST'])
@login_required
def toggle_task(task_id):
    task = Task.query.get_or_404(task_id)

    if task.user_id != current_user.id:
        return jsonify({'success': False, 'message': 'Not authorized'})

    # Toggle the status
    if task.status == 'completed':
        task.status = 'pending'
        task.completed_at = None
    else:
        task.status = 'completed'
        task.completed_at = datetime.utcnow()

    db.session.commit()
    return jsonify({'success': True})


@app.route('/delete-task/<int:task_id>', methods=['POST'])
@login_required
def delete_task(task_id):
    task = Task.query.get_or_404(task_id)

    if task.user_id != current_user.id:
        return jsonify({'success': False, 'message': 'Not authorized'})

    db.session.delete(task)
    db.session.commit()
    return jsonify({'success': True})


@app.route('/progress', methods=['GET', 'POST'])
@login_required
def progress():
    if request.method == 'POST':
        skill_area = request.form.get('skill_area')
        level = request.form.get('level')

        existing_progress = Progress.query.filter_by(
            user_id=current_user.id,
            skill_area=skill_area
        ).first()

        if existing_progress:
            existing_progress.level = level
            existing_progress.updated_at = datetime.utcnow()
        else:
            new_progress = Progress(
                user_id=current_user.id,
                skill_area=skill_area,
                level=level
            )
            db.session.add(new_progress)

        db.session.commit()
        flash('Progress updated successfully!')
        return redirect(url_for('progress'))

    progress_records = Progress.query.filter_by(user_id=current_user.id).all()
    return render_template('progress.html', progress_records=progress_records)

@app.route('/student_progress/<int:student_id>', methods=['GET'])
@login_required
def student_progress(student_id):
    if current_user.role != 'mentor':
        flash('You must be a mentor to view student progress.', 'error')
        return redirect(url_for('home'))

    student = User.query.get_or_404(student_id)
    student_progress_reports = Progress.query.filter_by(user_id=student_id).order_by(Progress.updated_at.desc()).all()

    if not student_progress_reports:
        flash('No progress records found for this student.', 'info')

    return render_template(
        'student_progress.html',
        student=student,
        progress_reports=student_progress_reports
    )
@app.route('/mentor/students', methods=['GET'])
@login_required
def mentor_students():
    if current_user.role != 'mentor':
        flash('Access denied.', 'error')
        return redirect(url_for('home'))

    # Option 1: show all students
    students = User.query.filter_by(role='student').all()



    return render_template('mentor_student_list.html', students=students)

@app.route('/chat')
@login_required
def chat():
    chat_history = ChatHistory.query.filter_by(user_id=current_user.id).order_by(ChatHistory.created_at.desc()).limit(
        10).all()
    return render_template('chat.html', chat_history=chat_history)


@app.route('/api/chat', methods=['POST'])
@login_required
def chat_api():
    message = request.json.get('message', '')

    # Get comprehensive user data for context
    # Get all tasks for statistics
    all_tasks = Task.query.filter_by(user_id=current_user.id).all()
    all_task_data = [
        {
            'id': task.id,
            'title': task.title,
            'description': task.description,
            'status': task.status,
            'type': task.type,
            'due_date': task.due_date,
            'completed_at': task.completed_at
        }
        for task in all_tasks
    ]

    # Get recent tasks
    recent_tasks = Task.query.filter_by(user_id=current_user.id).order_by(Task.created_at.desc()).limit(5).all()
    recent_task_data = [
        {
            'title': task.title,
            'status': task.status,
            'type': task.type,
            'due_date': task.due_date
        }
        for task in recent_tasks
    ]

    # Get recently completed tasks (last 7 days)
    week_ago = datetime.utcnow() - timedelta(days=7)
    recently_completed = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status == 'completed',
        Task.completed_at >= week_ago
    ).order_by(Task.completed_at.desc()).all()

    recently_completed_data = [
        {
            'title': task.title,
            'type': task.type,
            'completed_at': task.completed_at
        }
        for task in recently_completed
    ]

    # Get upcoming reminders
    now = datetime.utcnow()
    upcoming_reminders = Reminder.query.filter(
        Reminder.user_id == current_user.id,
        Reminder.sent == False,
        Reminder.trigger_time > now
    ).order_by(Reminder.trigger_time).all()

    upcoming_reminder_data = [
        {
            'message': reminder.message,
            'time': reminder.trigger_time.strftime('%Y-%m-%d %H:%M')
        }
        for reminder in upcoming_reminders
    ]

    # Get progress records
    progress_records = Progress.query.filter_by(user_id=current_user.id).all()
    progress_data = [
        {
            'skill': prog.skill_area,
            'level': prog.level,
            'updated_at': prog.updated_at
        }
        for prog in progress_records
    ]

    # Compile all user data for context
    user_data = {
        'name': current_user.name,
        'role': current_user.role,
        'recent_tasks': recent_task_data,
        'all_tasks': all_task_data,
        'progress_areas': progress_data,
        'recently_completed': recently_completed_data,
        'upcoming_reminders': upcoming_reminder_data
    }

    # Get recent chat history
    chat_history = [
        {'message': chat.message, 'response': chat.response}
        for chat in
        ChatHistory.query.filter_by(user_id=current_user.id).order_by(ChatHistory.created_at.desc()).limit(5).all()
    ]

    # Get response from Gemini
    response = get_gemini_response(message, user_data, chat_history)

    # Save to chat history
    new_chat = ChatHistory(
        user_id=current_user.id,
        message=message,
        response=response
    )
    db.session.add(new_chat)
    db.session.commit()

    # Process special commands in the message
    try:
        # 1. Task creation
        if any(phrase in message.lower() for phrase in ["create task", "add task", "new task", "assign task"]):
            # Use Gemini to extract task details
            task_extraction_prompt = f"""
            Extract task information from this message: "{message}"
            Format the response as a JSON with these fields:
            - title: the task title
            - description: task description if available
            - type: one of "technical", "aptitude", or "softskill"
            - due_date: due date in YYYY-MM-DD format, if mentioned

            Only return the JSON, nothing else.
            """

            task_info = get_gemini_response(task_extraction_prompt)
            try:
                task_data = json.loads(task_info)

                # Create the task
                due_date = None
                if task_data.get('due_date'):
                    try:
                        due_date = datetime.strptime(task_data['due_date'], '%Y-%m-%d')
                    except ValueError:
                        pass

                new_task = Task(
                    user_id=current_user.id,
                    title=task_data['title'],
                    description=task_data.get('description', ''),
                    type=task_data.get('type', 'technical'),
                    due_date=due_date
                )
                db.session.add(new_task)
                db.session.commit()
            except json.JSONDecodeError:
                print(f"Error decoding task JSON: {task_info}")

        # 2. Update progress
        if any(phrase in message.lower() for phrase in
               ["update progress", "track progress", "set skill", "my skill level"]):
            # Extract progress information
            progress_extraction_prompt = f"""
            Extract skill progress information from this message: "{message}"
            Format the response as a JSON with these fields:
            - skill_area: the skill area name
            - level: one of "Beginner", "Intermediate", or "Advanced"

            Only return the JSON, nothing else.
            """

            progress_info = get_gemini_response(progress_extraction_prompt)
            try:
                progress_data = json.loads(progress_info)

                # Update or create progress record
                existing_progress = Progress.query.filter_by(
                    user_id=current_user.id,
                    skill_area=progress_data['skill_area']
                ).first()

                if existing_progress:
                    existing_progress.level = progress_data['level']
                    existing_progress.updated_at = datetime.utcnow()
                else:
                    new_progress = Progress(
                        user_id=current_user.id,
                        skill_area=progress_data['skill_area'],
                        level=progress_data['level']
                    )
                    db.session.add(new_progress)

                db.session.commit()
            except json.JSONDecodeError:
                print(f"Error decoding progress JSON: {progress_info}")

        # 3. Set reminders
        if any(phrase in message.lower() for phrase in
               ["remind me", "set reminder", "create reminder", "new reminder"]):
            # Extract reminder information
            reminder_extraction_prompt = f"""
            Extract reminder information from this message: "{message}"
            Format the response as a JSON with these fields:
            - message: the reminder message
            - trigger_time: when to trigger the reminder in YYYY-MM-DD HH:MM format

            Only return the JSON, nothing else.
            """

            reminder_info = get_gemini_response(reminder_extraction_prompt)
            try:
                reminder_data = json.loads(reminder_info)

                # Create reminder
                try:
                    trigger_time = datetime.strptime(reminder_data['trigger_time'], '%Y-%m-%d %H:%M')

                    new_reminder = Reminder(
                        user_id=current_user.id,
                        message=reminder_data['message'],
                        trigger_time=trigger_time
                    )
                    db.session.add(new_reminder)
                    db.session.commit()
                except ValueError:
                    print("Invalid date format for reminder")
            except json.JSONDecodeError:
                print(f"Error decoding reminder JSON: {reminder_info}")
    except Exception as e:
        print(f"Error processing special command: {e}")

    return jsonify({'response': response})

from flask import Flask, render_template, request, redirect, url_for, flash
from flask_login import login_required, current_user
from datetime import datetime, timedelta
from sqlalchemy import func


# Reports list route
@app.route('/reports')
@login_required
def reports():
    reports = Report.query.filter_by(user_id=current_user.id).order_by(Report.created_at.desc()).all()
    return render_template('reports.html', reports=reports)


# Weekly report display
@app.route('/weekly_report')
@login_required
def weekly_report():
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=7)

    completed_tasks = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status == 'completed',
        Task.completed_at.between(start_date, end_date)
    ).order_by(Task.completed_at.desc()).all()

    new_tasks = Task.query.filter(
        Task.user_id == current_user.id,
        Task.created_at.between(start_date, end_date)
    ).order_by(Task.created_at.desc()).all()

    overdue_tasks = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status != 'completed',
        Task.due_date < end_date
    ).order_by(Task.due_date).all()

    next_week = end_date + timedelta(days=7)
    upcoming_tasks = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status != 'completed',
        Task.due_date.between(end_date, next_week)
    ).order_by(Task.due_date).all()

    progress_updates = Progress.query.filter(
        Progress.user_id == current_user.id,
        Progress.updated_at.between(start_date, end_date)
    ).order_by(Progress.updated_at.desc()).all()

    total_completed_this_week = len(completed_tasks)
    total_added_this_week = len(new_tasks)

    completion_by_type = {}
    for task_type in ['technical', 'aptitude', 'softskill']:
        type_completed = sum(1 for task in completed_tasks if task.type == task_type)
        completion_by_type[task_type] = type_completed

    productivity_score = total_completed_this_week * 10 - len(overdue_tasks) * 5
    productivity_score = max(0, productivity_score)

    improvement_areas = db.session.query(
        Task.type, func.count(Task.id).label('count')
    ).filter(
        Task.user_id == current_user.id,
        Task.status != 'completed'
    ).group_by(Task.type).order_by(func.count(Task.id).desc()).all()

    days_of_week = [(end_date - timedelta(days=i)).strftime('%a') for i in range(6, -1, -1)]

    daily_completion = []
    for i in range(6, -1, -1):
        day_date = end_date - timedelta(days=i)
        next_day = day_date + timedelta(days=1)
        count = Task.query.filter(
            Task.user_id == current_user.id,
            Task.status == 'completed',
            Task.completed_at.between(day_date, next_day)
        ).count()
        daily_completion.append(count)

    return render_template(
        'weekly_report.html',
        start_date=start_date,
        end_date=end_date,
        completed_tasks=completed_tasks,
        new_tasks=new_tasks,
        overdue_tasks=overdue_tasks,
        upcoming_tasks=upcoming_tasks,
        progress_updates=progress_updates,
        total_completed=total_completed_this_week,
        total_added=total_added_this_week,
        completion_by_type=completion_by_type,
        productivity_score=productivity_score,
        improvement_areas=improvement_areas,
        days_of_week=days_of_week,
        daily_completion=daily_completion
    )


# Save the weekly report
@app.route('/generate_weekly_report', methods=['POST'])
@login_required
def generate_weekly_report():
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=7)

    completed_count = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status == 'completed',
        Task.completed_at.between(start_date, end_date)
    ).count()

    new_count = Task.query.filter(
        Task.user_id == current_user.id,
        Task.created_at.between(start_date, end_date)
    ).count()

    overdue_count = Task.query.filter(
        Task.user_id == current_user.id,
        Task.status != 'completed',
        Task.due_date < end_date
    ).count()

    completion_by_type = {}
    for task_type in ['technical', 'aptitude', 'softskill']:
        type_completed = Task.query.filter(
            Task.user_id == current_user.id,
            Task.status == 'completed',
            Task.completed_at.between(start_date, end_date),
            Task.type == task_type
        ).count()
        completion_by_type[task_type] = type_completed

    progress_updates = Progress.query.filter(
        Progress.user_id == current_user.id,
        Progress.updated_at.between(start_date, end_date)
    ).all()

    progress_data = []
    for update in progress_updates:
        progress_data.append({
            'skill_area': update.skill_area,
            'level': update.level,
            'updated_at': update.updated_at.strftime('%Y-%m-%d %H:%M')
        })

    productivity_score = completed_count * 10 - overdue_count * 5
    productivity_score = max(0, productivity_score)

    report_content = {
        'period_start': start_date.strftime('%Y-%m-%d'),
        'period_end': end_date.strftime('%Y-%m-%d'),
        'tasks': {
            'completed': completed_count,
            'added': new_count,
            'overdue': overdue_count,
            'completion_by_type': completion_by_type
        },
        'progress_updates': progress_data,
        'productivity_score': productivity_score
    }

    new_report = Report(
        user_id=current_user.id,
        report_type='weekly_summary',
        content=report_content
    )
    db.session.add(new_report)
    db.session.commit()

    flash('Weekly report saved successfully!')
    return redirect(url_for('weekly_report'))


# Generate custom report
@app.route('/generate_report', methods=['POST'])
@login_required
def generate_report():
    report_type = request.form.get('report_type')

    if report_type == 'task_completion':
        total_tasks = Task.query.filter_by(user_id=current_user.id).count()
        completed_tasks = Task.query.filter_by(user_id=current_user.id, status='completed').count()
        completion_rate = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0

        tasks_by_type = {}
        for task_type in ['technical', 'aptitude', 'softskill']:
            type_total = Task.query.filter_by(user_id=current_user.id, type=task_type).count()
            type_completed = Task.query.filter_by(user_id=current_user.id, type=task_type, status='completed').count()
            tasks_by_type[task_type] = {
                'total': type_total,
                'completed': type_completed,
                'rate': (type_completed / type_total * 100) if type_total > 0 else 0
            }

        report_content = {
            'total_tasks': total_tasks,
            'completed_tasks': completed_tasks,
            'completion_rate': completion_rate,
            'tasks_by_type': tasks_by_type
        }

    elif report_type == 'progress_summary':
        progress_records = Progress.query.filter_by(user_id=current_user.id).all()
        progress_data = {
            'levels': {'Beginner': 0, 'Intermediate': 0, 'Advanced': 0},
            'skills': {}
        }
        for record in progress_records:
            progress_data['levels'][record.level] += 1
            progress_data['skills'][record.skill_area] = record.level

        report_content = progress_data

    else:
        flash('Invalid report type')
        return redirect(url_for('reports'))

    new_report = Report(
        user_id=current_user.id,
        report_type=report_type,
        content=report_content
    )
    db.session.add(new_report)
    db.session.commit()

    flash('Report generated successfully!')
    return redirect(url_for('reports'))


# View a saved report
@app.route('/view_report/<int:report_id>')
@login_required
def view_report(report_id):
    report = Report.query.get_or_404(report_id)

    if report.user_id != current_user.id:
        flash('Not authorized')
        return redirect(url_for('reports'))

    return render_template('view_report.html', report=report)


@app.route('/feedback', methods=['GET', 'POST'])
@login_required
def feedback():
    # Default to page 1 if the page argument is not present
    page = request.args.get('page', 1, type=int)

    # Get all students (assuming you have a Student model)
    students = User.query.filter_by(role='student').all()

    if current_user.role == 'mentor':
        if request.method == 'POST':
            student_id = request.form.get('student_id')
            message = request.form.get('message')
            rating = request.form.get('rating')

            # Check if rating is required (using a variable that should be defined elsewhere)
            rating_required = True  # Set this based on your application's requirements

            if not student_id or not message or (not rating and rating_required):
                flash("Please fill in all required fields.", "error")
                return redirect(url_for('feedback'))

            new_feedback = Feedback(
                mentor_id=current_user.id,
                student_id=student_id,
                message=message,
                rating=rating
            )
            db.session.add(new_feedback)
            db.session.commit()

            flash('âœ… Feedback provided successfully!')
            return redirect(url_for('feedback'))

        # Get the mentor's past feedback
        feedbacks = Feedback.query.filter_by(mentor_id=current_user.id) \
            .order_by(Feedback.created_at.desc()) \
            .paginate(page=page, per_page=10, error_out=False)

        return render_template('mentor_feedback.html',
                               students=students,
                               feedbacks=feedbacks.items)


    # Handle student flow
    elif current_user.role == 'student':
        # Get feedback received by the student
        feedbacks = Feedback.query.filter_by(student_id=current_user.id) \
            .order_by(Feedback.created_at.desc()) \
            .paginate(page=page, per_page=10, error_out=False)

        # Get all mentors (optional - if you want to display mentor information)
        mentors = User.query.filter_by(role='mentor').all()

        return render_template('student_feedback.html',
                               feedbacks=feedbacks.items,
                               mentors=mentors)

    # If not a mentor nor student redirect to another page or show an error
    flash("Access denied. Only mentors and student can provide feedback.", "error")
    return redirect(url_for('dashboard'))  # Replace with appropriate route
@app.route('/reminders', methods=['GET', 'POST'])
@login_required
def reminders():
    if request.method == 'POST':
        message = request.form.get('message')
        trigger_time_str = request.form.get('trigger_time')

        trigger_time = datetime.strptime(trigger_time_str, '%Y-%m-%dT%H:%M')

        new_reminder = Reminder(
            user_id=current_user.id,
            message=message,
            trigger_time=trigger_time
        )
        db.session.add(new_reminder)
        db.session.commit()

        flash('Reminder set successfully!')
        return redirect(url_for('reminders'))

    reminders = Reminder.query.filter_by(user_id=current_user.id).order_by(Reminder.trigger_time).all()
    return render_template('reminders.html', reminders=reminders)


# Check for due reminders (would typically be done with a scheduler like Celery)
@app.route('/check_reminders')
def check_reminders():
    now = datetime.utcnow()

    due_reminders = Reminder.query.filter(
        Reminder.sent == False,
        Reminder.trigger_time <= now
    ).all()

    for reminder in due_reminders:
        reminder.sent = True

        # In a real app, you might send notifications here
        # For now, we'll just mark them as sent

    db.session.commit()

    return jsonify({'reminders_processed': len(due_reminders)})
@app.route('/mentor/dashboard')
def mentor_dashboard():
    students = User.query.filter_by(role='student').all()
    return render_template('mentor_feedback.html', students=students)

@app.route('/mentor/feedback', methods=['POST'])
def give_feedback():
    mentor_id = session['user_id']
    student_id = request.form['student_id']
    message = request.form['message']
    rating = request.form['rating']

    feedback = Feedback(
        mentor_id=mentor_id,
        student_id=student_id,
        message=message,
        rating=int(rating),
        timestamp=datetime.utcnow()
    )
    db.session.add(feedback)
    db.session.commit()
    return redirect('/mentor/dashboard')
from collections import Counter


@app.route('/analytics')
@login_required
def analytics():
    # Get users for the bar chart
    users = User.query.all()

    # Bar chart data - task completion by user
    labels = [user.name for user in users]
    values = [Task.query.filter_by(user_id=user.id, status='completed').count() for user in users]

    # Get progress data for pie chart
    progress_records = Progress.query.all()
    skill_counts = {}

    for record in progress_records:
        level = record.level
        if level not in skill_counts:
            skill_counts[level] = 0
        skill_counts[level] += 1

    skill_labels = list(skill_counts.keys())
    skill_data = list(skill_counts.values())

    return render_template(
        'analytics.html',
        labels=labels,
        values=values,
        skill_labels=skill_labels,
        skill_data=skill_data
    )


# API route for task analytics
@app.route('/api/analytics/tasks', methods=['GET'])
@login_required
def api_task_analytics():
    """API endpoint to get task completion data by user"""
    try:
        # Get all users (adjust query according to your database schema)
        users = User.query.all()
        labels = [user.name for user in users]

        # Count completed tasks for each user
        values = []
        for user in users:
            completed_count = Task.query.filter_by(user_id=user.id, status='completed').count()
            values.append(completed_count)

        return jsonify({
            'labels': labels,
            'values': values
        })
    except Exception as e:
        app.logger.error(f"Error in task analytics: {str(e)}")
        return jsonify({
            'error': 'Failed to fetch task analytics',
            'labels': [],
            'values': []
        })


# API route for skill level distribution
@app.route('/api/analytics/skills', methods=['GET'])
@login_required
def api_skill_analytics():
    """API endpoint to get skill level distribution data"""
    try:
        # Define skill levels
        skill_levels = ['Beginner', 'Intermediate', 'Advanced', 'Expert']

        # Count users or records at each skill level
        # Adjust according to your database schema
        skill_counts = []
        for level in skill_levels:
            count = progress.query.filter_by(level=level).count()
            skill_counts.append(count)

        return jsonify({
            'labels': skill_levels,
            'values': skill_counts
        })
    except Exception as e:
        app.logger.error(f"Error in skill analytics: {str(e)}")
        return jsonify({
            'labels': [],
            'values': []
        })


# API route for user's skills progress (radar chart)
@app.route('/api/analytics/progress', methods=['GET'])
@login_required
def api_progress_analytics():
    """API endpoint to get current user's progress records for radar chart"""
    try:
        # Get progress records for current user
        # Adjust query according to your database schema
        progress_records = Progress.query.filter_by(user_id=current_user.id).all()

        # Format records for the radar chart
        records_data = []
        for record in progress_records:
            records_data.append({
                'skill_area': record.skill_area,
                'level': record.level
            })

        return jsonify({
            'records': records_data
        })
    except Exception as e:
        app.logger.error(f"Error in progress analytics: {str(e)}")
        return jsonify({
            'records': []
        })


# API route for updating task status (no CSRF)
@app.route('/api/tasks/<int:task_id>/status', methods=['PUT'])
@login_required
def update_task_status(task_id):
    """API endpoint to update a task's status"""
    try:
        data = request.json
        new_status = data.get('status')

        if not new_status:
            return jsonify({'success': False, 'message': 'Status not provided'})

        task = Task.query.get(task_id)
        if not task:
            return jsonify({'success': False, 'message': 'Task not found'})

        # Check if user has permission to update this task
        if task.user_id != current_user.id and current_user.role != 'admin':
            return jsonify({'success': False, 'message': 'Not authorized'})

        # Update task status
        task.status = new_status
        db.session.commit()

        # Check if task is overdue
        is_overdue = False
        if task.due_date and task.due_date < datetime.now() and new_status != 'completed':
            is_overdue = True

        return jsonify({
            'success': True,
            'message': 'Task status updated successfully',
            'is_overdue': is_overdue
        })
    except Exception as e:
        app.logger.error(f"Error updating task status: {str(e)}")
        return jsonify({
            'success': False,
            'message': f"An error occurred: {str(e)}"
        })

### MENTOR INTERFACE ###
@app.route("/recommend", methods=["POST"])
def recommend_skills():
    data = request.json
    current_skills = data.get("skills")
    # dummy logic: recommend 'Data Structures' if 'Python' is known
    if 'Python' in current_skills:
        return jsonify({"recommendations": ["Data Structures", "OOP"]})
    return jsonify({"recommendations": ["Python"]})


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(host='0.0.0.0', port=3000, debug=True)
